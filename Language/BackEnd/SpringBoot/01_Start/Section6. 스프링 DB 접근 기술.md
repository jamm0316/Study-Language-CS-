[<back](https://www.notion.so/Spring-2cf44a3f25f542dfbcc88e2390cee6e3?pvs=21)

---

<aside>
📃 목차

</aside>

---

## H2 데이터 베이스 설치

- H2 Database Engine 사용
    - 개발이나 테스트 용도로 가볍고 편리한 DB, 웹 화면 제공
- **설치방법**
    - https://www.h2database.com/html/main.html 홈페이지 접속 → All Plaform 다운로드 → 알집 풀기
        
        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/6b8d40ba-5287-42be-84df-56b1c96a2c05/35feee01-50e8-4512-931c-98f0beff0193/image.png)
        
    - `cd h2` → `cd bin` → `ls -arlth` → `chmod 755 h2.sh`(실행권한 부여) → `./h2.sh`
        
        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/6b8d40ba-5287-42be-84df-56b1c96a2c05/41f7e6c3-2eed-4381-b1f0-a27721441481/image.png)
        
    - 웹 화면 실행 → 연결 클릭
        
        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/6b8d40ba-5287-42be-84df-56b1c96a2c05/164e8d12-4620-4a5e-90f9-edc7345a7385/image.png)
        
    - 좌측 상단 빨간색 `연결 끊기` 버튼 클릭
        
        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/6b8d40ba-5287-42be-84df-56b1c96a2c05/9f0d1027-98fc-4e74-af7a-4902d3a23766/image.png)
        
    - terminal 우클릭 → New Window 클릭
        
        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/6b8d40ba-5287-42be-84df-56b1c96a2c05/e01cc1da-7246-4291-8023-de7a6b84af0c/image.png)
        
    - `ls -arlth` → `test.mv.db`가 있는지 확인
        
        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/6b8d40ba-5287-42be-84df-56b1c96a2c05/9013f186-f762-4ee1-abd5-1c0ac99d9e04/image.png)
        
    - **JDBC URL**
        - `jdbc:h2:**~/test**`: 여기서 `~/test`는 내 홈화면에 있는 test파일 경로를 말하는 것.
            - 파일로 접근하게 되면 웹콘솔과 애플리케이션 동시 접속이 안되는 경우 발생
                
                ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/6b8d40ba-5287-42be-84df-56b1c96a2c05/782e9a7c-a8a2-4d2a-a204-d209fb8978d0/image.png)
                
                → 오류 발생의 원인
                
    - `jdbc:h2:tcp://localhost/~/test` : tcp소켓을 통해 접근하면 여러군데에서 접근 가능하다.
        
        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/6b8d40ba-5287-42be-84df-56b1c96a2c05/99c9f7c5-de4b-42b2-aa38-c6c1f33e65f0/image.png)
        
    - 문제 있을 시
        - `연결 끊기` 후 터미널을 통해 `test.mv.db`를 지운다.
            - `rm test.mv.db`
        - 서버 내린다.
        - [`cd h2` → `cd bin` → `ls -arlth` → `chmod 755 h2.sh`(실행권한 부여) → `./h2.sh`](https://www.notion.so/cd-h2-cd-bin-ls-arlth-chmod-755-h2-sh-h2-sh-93535e0581ba4e799b9031c725cef5af?pvs=21) 여기서 부터 다시 시작
1. **MEMBER table 만들기**
    
    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/6b8d40ba-5287-42be-84df-56b1c96a2c05/e18cc7cb-a5ab-46cf-9550-7860fa1d8b88/image.png)
    
    ```
    create table member
    (
        id bigint generated by default as identity,
        name varchar(255),
        primary key (id)
    );
    ```
    
    - 입력 후 → `ctrl + enter`
    - 해석
        - 도메인의 id, name을 넣음
        - id: Java Long 타입 → SQL bigint 타입
        - name: String 타입 → varchar 타입
        - PK는 id로 잡음

1. **MEMBER table 조회**
    - 직접 타이핑
        
        ```
        select * from member
        ```
        
        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/6b8d40ba-5287-42be-84df-56b1c96a2c05/3e910d3b-e9a2-4f24-ab20-94cae31c4a97/image.png)
        
    
    - SQL문: 창이 모두 지워진 상태에서 MEMBER를 클릭하면 해당 실행문이 자동 입력됨.
        
        
        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/6b8d40ba-5287-42be-84df-56b1c96a2c05/aa44e633-8f6b-477b-a09c-7937836304e8/image.png)
        
        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/6b8d40ba-5287-42be-84df-56b1c96a2c05/7763c51c-b6f0-49fd-a1f7-adad861a5d55/image.png)
        
2. **데이터 입력**
    
    ```
    insert into member(name) values('spring')
    ```
    
    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/6b8d40ba-5287-42be-84df-56b1c96a2c05/2915eed9-310b-4ece-8dc5-1ed50a197b7f/image.png)
    
    - 입력된 데이터 확인
        
        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/6b8d40ba-5287-42be-84df-56b1c96a2c05/12f3574d-7804-4c99-b519-dc94e8949ce6/image.png)
        
    
    ```
    insert into member(name) value('spring2')
    select * from member
    ```
    
    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/6b8d40ba-5287-42be-84df-56b1c96a2c05/7ab88d0d-496f-47d1-9666-2d9967faebe0/image.png)
    
    - `name`을 지정하지 않아도 제너레이터로 인해 1씩 증가함.
        - `repository` 또한 `setId(++sequence);` 로 인해 `Id`가 `1`씩 증가함.
            
            ```java
            @Override
            public Member save(Member member) {
                member.setId(++sequence);
                store.put(member.getId(), member);
                return member;
            ```
            
3. 데이터 관리

`hello-spring copy/sql/ddl.sql`

**ddl.sql**

```java
create table member
(
    id bigint generated by default as identity,
    name varchar(255),
    primary key (id)
);
```

## 순수 Jdbc

### 환경 설정

**build.gradle 파일에 jdbc, h2 데이터베이스 관련 라이브러리 추가**

`hello-spring copy/build.gradle`

**build.gradle**

```java
implementation 'org.springframework.boot:spring-boot-starter-jdbc'
runtimeOnly 'com.h2database:h2'
```

`hello-spring copy/src/main/resources/application.properties`

**application.properties**

```java
spring.datasource.url=jdbc:h2:tcp://localhost/~/test
spring.datasource.username=sa
spring.datasource.driver-class-name=org.h2.Driver
```

- 코끼리 리프레쉬 버튼 클릭 → `org.h2.Driver` 인스톨 됨
- 여기서 `spring.datasource.username=sa` 코드를 입력하지 않을 시, db의 사용자 이름을 찾을 수 없어 연결이 되지 않음.

`hello-spring/src/main/java/hello/hello_spring/repository/JdbcMemberRepository.java`

**JdbcMemberRepository.java**

```java
package hello.hello_spring.repository;
import hello.hello_spring.domain.Member;
import org.springframework.jdbc.datasource.DataSourceUtils;
import javax.sql.DataSource;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
public class JdbcMemberRepository implements MemberRepository {
    private final DataSource dataSource;
    public JdbcMemberRepository(DataSource dataSource) {
        this.dataSource = dataSource;
    }
    @Override
    public Member save(Member member) {
        String sql = "insert into member(name) values(?)";
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
            pstmt.setString(1, member.getName());
            pstmt.executeUpdate();
            rs = pstmt.getGeneratedKeys();
            if (rs.next()) {
                member.setId(rs.getLong(1));
            } else {
                throw new SQLException("id 조회 실패");
            }
            return member;
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            close(conn, pstmt, rs);
        }
    }
    @Override
    public Optional<Member> findById(Long id) {
        String sql = "select * from member where id = ?";
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql);
            pstmt.setLong(1, id);
            rs = pstmt.executeQuery();
            if(rs.next()) {
                Member member = new Member();
                member.setId(rs.getLong("id"));
                member.setName(rs.getString("name"));
                return Optional.of(member);
            } else {
                return Optional.empty();
            }
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            close(conn, pstmt, rs);
        }
    }
    @Override
    public List<Member> findAll() {
        String sql = "select * from member";
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql);
            rs = pstmt.executeQuery();
            List<Member> members = new ArrayList<>();
            while(rs.next()) {
                Member member = new Member();
                member.setId(rs.getLong("id"));
                member.setName(rs.getString("name"));
                members.add(member);
            }
            return members;
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            close(conn, pstmt, rs);
        }
    }
    @Override
    public Optional<Member> findByName(String name) {
        String sql = "select * from member where name = ?";
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql);
            pstmt.setString(1, name);
            rs = pstmt.executeQuery();
            if(rs.next()) {
                Member member = new Member();
                member.setId(rs.getLong("id"));
                member.setName(rs.getString("name"));
                return Optional.of(member);
            }
            return Optional.empty();
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            close(conn, pstmt, rs);
        }
    }
    private Connection getConnection() {
        return DataSourceUtils.getConnection(dataSource);
    }
    private void close(Connection conn, PreparedStatement pstmt, ResultSet rs) {
        try {
            if (rs != null) {
                rs.close();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        try {
            if (pstmt != null) {
                pstmt.close();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        try {
            if (conn != null) {
                close(conn);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
    private void close(Connection conn) throws SQLException {
        DataSourceUtils.releaseConnection(conn, dataSource);
    }
}
```

- DataSource는 데이터베이스 커넥션을 획득할 때 사용하는 객체. 스프링 부트는 데이터베이스 커넥션 정보를 바탕으로 DataSource를 생성하고 스프링 빈으로 만들어준다. 그래서 DI를 받을 수 있다.

**구현 클래스 추가 이미지**

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/6b8d40ba-5287-42be-84df-56b1c96a2c05/c2a91402-e1af-4166-81e8-9ef6c360e3e6/aa6a21e9-3adf-4ed5-b35d-e99a873dd4a8.png)

**스프링 설정 이미지**

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/6b8d40ba-5287-42be-84df-56b1c96a2c05/001e8741-a250-4da5-afaa-3b89ae32ca3e/5dece439-1df4-4428-8dfe-443459ef6dc1.png)

- 개방 폐쇄 원칙 (OCP: Open-Closed Principle)
    - 확장에는 열려있고 수정, 변경에는 닫혀있다.
- 스프링 DI(Dependencies Injection)를 이용하면, **기존 코드를 전혀 손대지 않고, 설정만으로 구현 클래스를 변경**할 수 있다.
- 회원을 등록하고 DB에 결과가 잘 입력됐는지 확인
- 데이터를 DB에 저장하므로 스프링 서버를 다시 실행해도 데이터가 안전하게 저장됨.

## 스프링 통합 테스트

스프링 컨테이너와 DB까지 연결한 통합 테스트 진행

`hello-spring/src/test/java/hello/hello_spring/service/MemberServiceIntergrationTest.java`

**MemberServiceIntergrationTest.java**

```java
package hello.hello_spring.service;
...

@SpringBootTest
//@Transactional
class MemberServiceIntergrationTest {

    @Autowired MemberService memberService;
    @Autowired MemberRepository memberRepository;
```

**실행 결과**

```java
java.lang.IllegalStateException: 이미 존재하는 회원입니다.
```

- 위에서 이미 `spring`이라는 이름을 가진 회원을 등록했고, DB에서 실행하는 것이기 때문에 DB를 클리어 해주어야함.
    
    ```java
    delete from member
    ```
    
    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/6b8d40ba-5287-42be-84df-56b1c96a2c05/74d53eaf-b5f2-49f1-b1dc-1b9e578789a6/image.png)
    
    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/6b8d40ba-5287-42be-84df-56b1c96a2c05/e4d683f7-500a-4556-95c6-4ad5eec86486/image.png)
    
- `MemberServiceIntergrationTest.java` ****코드를 실행하면, DB에 해당 이름이 올라가며 테스트가 진행된다.
- 그러나 테스트는 서로 영향을 주면 안된다. 하지만 DB에 데이터가 올라가는 순간 다른 테스트에 영향을 줌
- 이에 따라 `@Transaction` 애노테이션이 필요.
    - 트렌젝션이 걸고 인서트 쿼리 후 테스트가 끝나면 롤백한다.
        
        → `@Transaction`애노테이션을 통해 테스트가 시작되면서 데이터가 인서트 되고, 테스트가 끝나면 올라가있던 데이터들이 모두 롤백된다.
        

**MemberServiceIntergrationTest.java**

```java
package hello.hello_spring.service;
...

@SpringBootTest
//@Transactional
class MemberServiceIntergrationTest {

    @Autowired MemberService memberService;
    @Autowired MemberRepository memberRepository;
```

**실행결과**

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/6b8d40ba-5287-42be-84df-56b1c96a2c05/a80455b4-e2d3-400b-b102-47ab5f0979f4/image.png)

- `@SpringBootTest`: 스프링 컨테이너와 테스트를 함께 실행.
- `@Transactional`: 테스트 케이스에 이 애노테이션이 있으면, 테스트 시작 전에 트랜젝션을 시작하고, 테스트 완료 후에 항상 롤백한다. 이렇게 하면 DB에 데이터가 남지 않으므로 다음 테스트에 영향 주지 않는다.

## 스프링 JdbcTemplate

- 순수 Jdbc와 동일한 환경설정을 하면 된다.
- 스프링 Jdbc Template과 MyBatis 같은 라이브러리는 JDBC API에서 본 반복 코드를 대부분 제거해준다. 하지만 SQL은 직접 작성해야한다.

**스프링 JdbcTemplate 회원 리포지토리**

```java
package hello.hello_spring.repository;

import hello.hello_spring.domain.Member;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.simple.SimpleJdbcInsert;

import javax.sql.DataSource;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.*;

public class JdbcTemplateMemberRepository implements MemberRepository {

    private final JdbcTemplate jdbcTemplate;

    //@Autowired  -> 생성자가 하나만 있으면 스프링 빈이 자동으로 인젝션을 도와줌, 따라서 @Autowired 생략 가능
    public JdbcTemplateMemberRepository(DataSource dataSource) {
        jdbcTemplate = new JdbcTemplate(dataSource);
    }

    @Override
    public Member save(Member member) {
        SimpleJdbcInsert jdbcInsert = new SimpleJdbcInsert(jdbcTemplate);
        jdbcInsert.withTableName("member").usingGeneratedKeyColumns("id");

        Map<String, Object> parameters = new HashMap<>();
        parameters.put("name", member.getName());

        Number key = jdbcInsert.executeAndReturnKey(new MapSqlParameterSource(parameters));
        member.setId(key.longValue());
        return member;
    }

    @Override
    public Optional<Member> findById(Long id) {
        List<Member> result = jdbcTemplate.query("select * from member where id = ?", memberRowMapper(), id);
        return result.stream().findAny();
    }

    @Override
    public Optional<Member> findByName(String name) {
        List<Member> result = jdbcTemplate.query("select * from member where name = ?", memberRowMapper(), name);
        return result.stream().findAny();    }

    @Override
    public List<Member> findAll() {
        return jdbcTemplate.query("select * from member", memberRowMapper());
    }

    private RowMapper<Member> memberRowMapper() {
        return (rs, rowNum) -> {
            Member member = new Member();
            member.setId(rs.getLong("id"));
            member.setName(rs.getString("name"));
            return member;
        };
    }
}
```

## JPA

- JPA는 기존의 반복 코드는 물론이고, 기본적인 SQL도 JPA가 직접 만들어서 실행해준다.
- JPA를 사용하면, SQL과 데이터 중심의 설계에서 객체 중심의 설계로 패러다임을 전환할 수 있다.
- JPA를 사용하면 개발 생산성을 크게 높일 수 있다.

`hello-spring/build.gradle`

**build.gradle**

```java
dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'
	implementation 'org.springframework.boot:spring-boot-starter-web'
	implementation 'org.springframework.boot:spring-boot-starter-jdbc'
	**implementation 'org.springframework.boot:spring-boot-starter-data-jpa'**
	runtimeOnly 'com.h2database:h2'
	testImplementation 'org.springframework.boot:spring-boot-starter-test'
	testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
```

`implementation 'org.springframework.boot:spring-boot-starter-data-jpa'` 추가

→`gradle refresh` 

`hello-spring/src/main/resources/application.properties`

**application.properties**

```java
spring.application.name=hello-spring
spring.datasource.url=jdbc:h2:tcp://localhost/~/test
spring.datasource.username=sa
spring.datasource.driver-class-name=org.h2.Driver
**spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=none**
```

`hello-spring/src/main/java/hello/hello_spring/repository/JpaMemberRepository.java`

**JpaMemberRepository.java**

```java
package hello.hello_spring.repository;

import hello.hello_spring.domain.Member;
import jakarta.persistence.EntityManager;

import java.util.List;
import java.util.Optional;

public class JpaMemberRepository implements MemberRepository {

    private final EntityManager em;

    public JpaMemberRepository(EntityManager em) {
        this.em = em;
    }

    @Override
    public Member save(Member member) {
        return null;
    }

    @Override
    public Optional<Member> findById(Long id) {
        return Optional.empty();
    }

    @Override
    public Optional<Member> findByName(String name) {
        return Optional.empty();
    }

    @Override
    public List<Member> findAll() {
        return List.of();
    }
}
```

## 스프링 데이터 JPA

스프링 부트와 JPA만 사용해도 개발 생산성이 많이 증가함.

개발해야할 코드도 확연히 줄어든다.

여기에 스프링 데이터 JPA를 사용하면, 기존의 한계를 리포지토리에 구현 클래스 없이 인터페이스만으로 개발을 완료할 수 있다.

그리고 반복 개발해온 기본 CRUD 기능도 스프링 데이터 JPA가 모두 제공.

지금까지 조금이라도 단순한고 반복이라 생각했던 개발 코드들이 확연히 줄어들고 핵심 비즈니스 로직 개발에 집중 가능.

> **주의: 스프링 데이터 JPA는 JPA를 편리하게 사용하도록 도와주는 기술. 따라서 JPA를 먼저 학습한 후 스프링 JPA학습 권장**
> 

`hello-spring/src/main/java/hello/hello_spring/repository/SringDataJpaMemberRepository.java` 

**SpringDataJpaMemberRepository.java**

```java
package hello.hello_spring.repository;

import hello.hello_spring.domain.Member;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface SringDataJpaMemberRepository extends JpaRepository<Member, Long>, MemberRepository {

    @Override
    Optional<Member> findByName(String name);
}
```

`hello-spring/src/main/java/hello/hello_spring/SpringConfig.java`

**SpringConfig.java**

```java
package hello.hello_spring;

import hello.hello_spring.repository.*;
import hello.hello_spring.service.MemberService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.sql.DataSource;

@Configuration
public class SpringConfig {

    private final MemberRepository memberRepository;

    public SpringConfig(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }

    @Bean
    public MemberService memberService() {
        return new MemberService(memberRepository);
    }
}
```

- 스프링데이터 JPA가 `SpringDataJpaMemberRepository`를 스프링 빈으로 자동 등록해줌

**스프링 데이터 JPA 제공 클래스**

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/6b8d40ba-5287-42be-84df-56b1c96a2c05/3618ea3f-32cf-40e7-9733-613c36b15256/8362ecf4-c5a3-4be0-a7b8-6d09a107a436.png)

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/6b8d40ba-5287-42be-84df-56b1c96a2c05/11986d1b-8249-4d0e-910c-1c9c53ed7656/97757844-ec32-4e8f-b7c2-da68a0597f65.png)

**스프링 데이터 JPA 제공 기능**

- 인터페이스를 통한 기본적인 CRUD
- `findName()`, `findByEmail()` 처럼 메서드 이름만으로 조회 가능.
- 페이징 기능 자동 제공

> 참고: 실무에서는 JPA와 스프링 데이터 JPA를 기본으로 사용, 복잡한 동적 쿼리는 Querydsl이라는 라이브러리를 사용. Querydsl을 사용하면 쿼리도 자바 코드로 안전하게 작성할 수 있고, 동적 쿼리도 편리하게 작성가능. 이 조합으로 해결하기 어려운 쿼리는 JPA가 제공하는 네이티브 쿼리를 사용하거나, 앞서 학습한 스프링 JdbcTemplate를 사용하면 된다.
>